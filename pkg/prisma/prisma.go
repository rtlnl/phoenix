// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Container(params ContainerWhereUniqueInput) *ContainerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ContainerWhereUniqueInput!", "Container"},
		"container",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

type ContainersParams struct {
	Where   *ContainerWhereInput   `json:"where,omitempty"`
	OrderBy *ContainerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) Containers(params *ContainersParams) *ContainerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ContainerWhereInput", "ContainerOrderByInput", "Container"},
		"containers",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExecArray{ret}
}

type ContainersConnectionParams struct {
	Where   *ContainerWhereInput   `json:"where,omitempty"`
	OrderBy *ContainerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) ContainersConnection(params *ContainersConnectionParams) ContainerConnectionExec {
	panic("not implemented")
}

func (client *Client) Model(params ModelWhereUniqueInput) *ModelExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ModelWhereUniqueInput!", "Model"},
		"model",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

type ModelsParams struct {
	Where   *ModelWhereInput   `json:"where,omitempty"`
	OrderBy *ModelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Models(params *ModelsParams) *ModelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ModelWhereInput", "ModelOrderByInput", "Model"},
		"models",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExecArray{ret}
}

type ModelsConnectionParams struct {
	Where   *ModelWhereInput   `json:"where,omitempty"`
	OrderBy *ModelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) ModelsConnection(params *ModelsConnectionParams) ModelConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateContainer(params ContainerCreateInput) *ContainerExec {
	ret := client.Client.Create(
		params,
		[2]string{"ContainerCreateInput!", "Container"},
		"createContainer",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

type ContainerUpdateParams struct {
	Data  ContainerUpdateInput      `json:"data"`
	Where ContainerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateContainer(params ContainerUpdateParams) *ContainerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ContainerUpdateInput!", "ContainerWhereUniqueInput!", "Container"},
		"updateContainer",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

type ContainerUpdateManyParams struct {
	Data  ContainerUpdateManyMutationInput `json:"data"`
	Where *ContainerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyContainers(params ContainerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ContainerUpdateManyMutationInput!", "ContainerWhereInput"},
		"updateManyContainers")
	return &BatchPayloadExec{exec}
}

type ContainerUpsertParams struct {
	Where  ContainerWhereUniqueInput `json:"where"`
	Create ContainerCreateInput      `json:"create"`
	Update ContainerUpdateInput      `json:"update"`
}

func (client *Client) UpsertContainer(params ContainerUpsertParams) *ContainerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ContainerWhereUniqueInput!", "ContainerCreateInput!", "ContainerUpdateInput!", "Container"},
		"upsertContainer",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

func (client *Client) DeleteContainer(params ContainerWhereUniqueInput) *ContainerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ContainerWhereUniqueInput!", "Container"},
		"deleteContainer",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

func (client *Client) DeleteManyContainers(params *ContainerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ContainerWhereInput", "deleteManyContainers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateModel(params ModelCreateInput) *ModelExec {
	ret := client.Client.Create(
		params,
		[2]string{"ModelCreateInput!", "Model"},
		"createModel",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

type ModelUpdateParams struct {
	Data  ModelUpdateInput      `json:"data"`
	Where ModelWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateModel(params ModelUpdateParams) *ModelExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ModelUpdateInput!", "ModelWhereUniqueInput!", "Model"},
		"updateModel",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

type ModelUpdateManyParams struct {
	Data  ModelUpdateManyMutationInput `json:"data"`
	Where *ModelWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyModels(params ModelUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ModelUpdateManyMutationInput!", "ModelWhereInput"},
		"updateManyModels")
	return &BatchPayloadExec{exec}
}

type ModelUpsertParams struct {
	Where  ModelWhereUniqueInput `json:"where"`
	Create ModelCreateInput      `json:"create"`
	Update ModelUpdateInput      `json:"update"`
}

func (client *Client) UpsertModel(params ModelUpsertParams) *ModelExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ModelWhereUniqueInput!", "ModelCreateInput!", "ModelUpdateInput!", "Model"},
		"upsertModel",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

func (client *Client) DeleteModel(params ModelWhereUniqueInput) *ModelExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ModelWhereUniqueInput!", "Model"},
		"deleteModel",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

func (client *Client) DeleteManyModels(params *ModelWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ModelWhereInput", "deleteManyModels")
	return &BatchPayloadExec{exec}
}

type ModelOrderByInput string

const (
	ModelOrderByInputIDAsc            ModelOrderByInput = "id_ASC"
	ModelOrderByInputIDDesc           ModelOrderByInput = "id_DESC"
	ModelOrderByInputNameAsc          ModelOrderByInput = "name_ASC"
	ModelOrderByInputNameDesc         ModelOrderByInput = "name_DESC"
	ModelOrderByInputConcatenatorAsc  ModelOrderByInput = "concatenator_ASC"
	ModelOrderByInputConcatenatorDesc ModelOrderByInput = "concatenator_DESC"
	ModelOrderByInputStageAsc         ModelOrderByInput = "stage_ASC"
	ModelOrderByInputStageDesc        ModelOrderByInput = "stage_DESC"
	ModelOrderByInputVersionAsc       ModelOrderByInput = "version_ASC"
	ModelOrderByInputVersionDesc      ModelOrderByInput = "version_DESC"
	ModelOrderByInputCreatedAtAsc     ModelOrderByInput = "createdAt_ASC"
	ModelOrderByInputCreatedAtDesc    ModelOrderByInput = "createdAt_DESC"
	ModelOrderByInputUpdatedAtAsc     ModelOrderByInput = "updatedAt_ASC"
	ModelOrderByInputUpdatedAtDesc    ModelOrderByInput = "updatedAt_DESC"
)

type ContainerOrderByInput string

const (
	ContainerOrderByInputIDAsc                ContainerOrderByInput = "id_ASC"
	ContainerOrderByInputIDDesc               ContainerOrderByInput = "id_DESC"
	ContainerOrderByInputPublicationPointAsc  ContainerOrderByInput = "publicationPoint_ASC"
	ContainerOrderByInputPublicationPointDesc ContainerOrderByInput = "publicationPoint_DESC"
	ContainerOrderByInputCampaignAsc          ContainerOrderByInput = "campaign_ASC"
	ContainerOrderByInputCampaignDesc         ContainerOrderByInput = "campaign_DESC"
	ContainerOrderByInputCreatedAtAsc         ContainerOrderByInput = "createdAt_ASC"
	ContainerOrderByInputCreatedAtDesc        ContainerOrderByInput = "createdAt_DESC"
	ContainerOrderByInputUpdatedAtAsc         ContainerOrderByInput = "updatedAt_ASC"
	ContainerOrderByInputUpdatedAtDesc        ContainerOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type ModelUpdateWithoutContainerIdDataInput struct {
	Name         *string                      `json:"name,omitempty"`
	SignalOrder  *ModelUpdatesignalOrderInput `json:"signalOrder,omitempty"`
	Concatenator *string                      `json:"concatenator,omitempty"`
	Stage        *string                      `json:"stage,omitempty"`
	Version      *string                      `json:"version,omitempty"`
}

type ContainerWhereUniqueInput struct {
	ID               *int32  `json:"id,omitempty"`
	PublicationPoint *string `json:"publicationPoint,omitempty"`
	Campaign         *string `json:"campaign,omitempty"`
}

type ModelUpsertWithWhereUniqueWithoutContainerIdInput struct {
	Where  ModelWhereUniqueInput                  `json:"where"`
	Update ModelUpdateWithoutContainerIdDataInput `json:"update"`
	Create ModelCreateWithoutContainerIdInput     `json:"create"`
}

type ContainerWhereInput struct {
	ID                            *int32                `json:"id,omitempty"`
	IDNot                         *int32                `json:"id_not,omitempty"`
	IDIn                          []int32               `json:"id_in,omitempty"`
	IDNotIn                       []int32               `json:"id_not_in,omitempty"`
	IDLt                          *int32                `json:"id_lt,omitempty"`
	IDLte                         *int32                `json:"id_lte,omitempty"`
	IDGt                          *int32                `json:"id_gt,omitempty"`
	IDGte                         *int32                `json:"id_gte,omitempty"`
	PublicationPoint              *string               `json:"publicationPoint,omitempty"`
	PublicationPointNot           *string               `json:"publicationPoint_not,omitempty"`
	PublicationPointIn            []string              `json:"publicationPoint_in,omitempty"`
	PublicationPointNotIn         []string              `json:"publicationPoint_not_in,omitempty"`
	PublicationPointLt            *string               `json:"publicationPoint_lt,omitempty"`
	PublicationPointLte           *string               `json:"publicationPoint_lte,omitempty"`
	PublicationPointGt            *string               `json:"publicationPoint_gt,omitempty"`
	PublicationPointGte           *string               `json:"publicationPoint_gte,omitempty"`
	PublicationPointContains      *string               `json:"publicationPoint_contains,omitempty"`
	PublicationPointNotContains   *string               `json:"publicationPoint_not_contains,omitempty"`
	PublicationPointStartsWith    *string               `json:"publicationPoint_starts_with,omitempty"`
	PublicationPointNotStartsWith *string               `json:"publicationPoint_not_starts_with,omitempty"`
	PublicationPointEndsWith      *string               `json:"publicationPoint_ends_with,omitempty"`
	PublicationPointNotEndsWith   *string               `json:"publicationPoint_not_ends_with,omitempty"`
	Campaign                      *string               `json:"campaign,omitempty"`
	CampaignNot                   *string               `json:"campaign_not,omitempty"`
	CampaignIn                    []string              `json:"campaign_in,omitempty"`
	CampaignNotIn                 []string              `json:"campaign_not_in,omitempty"`
	CampaignLt                    *string               `json:"campaign_lt,omitempty"`
	CampaignLte                   *string               `json:"campaign_lte,omitempty"`
	CampaignGt                    *string               `json:"campaign_gt,omitempty"`
	CampaignGte                   *string               `json:"campaign_gte,omitempty"`
	CampaignContains              *string               `json:"campaign_contains,omitempty"`
	CampaignNotContains           *string               `json:"campaign_not_contains,omitempty"`
	CampaignStartsWith            *string               `json:"campaign_starts_with,omitempty"`
	CampaignNotStartsWith         *string               `json:"campaign_not_starts_with,omitempty"`
	CampaignEndsWith              *string               `json:"campaign_ends_with,omitempty"`
	CampaignNotEndsWith           *string               `json:"campaign_not_ends_with,omitempty"`
	ModelsEvery                   *ModelWhereInput      `json:"models_every,omitempty"`
	ModelsSome                    *ModelWhereInput      `json:"models_some,omitempty"`
	ModelsNone                    *ModelWhereInput      `json:"models_none,omitempty"`
	CreatedAt                     *string               `json:"createdAt,omitempty"`
	CreatedAtNot                  *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string               `json:"updatedAt_gte,omitempty"`
	And                           []ContainerWhereInput `json:"AND,omitempty"`
	Or                            []ContainerWhereInput `json:"OR,omitempty"`
	Not                           []ContainerWhereInput `json:"NOT,omitempty"`
}

type ModelScalarWhereInput struct {
	ID                        *int32                  `json:"id,omitempty"`
	IDNot                     *int32                  `json:"id_not,omitempty"`
	IDIn                      []int32                 `json:"id_in,omitempty"`
	IDNotIn                   []int32                 `json:"id_not_in,omitempty"`
	IDLt                      *int32                  `json:"id_lt,omitempty"`
	IDLte                     *int32                  `json:"id_lte,omitempty"`
	IDGt                      *int32                  `json:"id_gt,omitempty"`
	IDGte                     *int32                  `json:"id_gte,omitempty"`
	Name                      *string                 `json:"name,omitempty"`
	NameNot                   *string                 `json:"name_not,omitempty"`
	NameIn                    []string                `json:"name_in,omitempty"`
	NameNotIn                 []string                `json:"name_not_in,omitempty"`
	NameLt                    *string                 `json:"name_lt,omitempty"`
	NameLte                   *string                 `json:"name_lte,omitempty"`
	NameGt                    *string                 `json:"name_gt,omitempty"`
	NameGte                   *string                 `json:"name_gte,omitempty"`
	NameContains              *string                 `json:"name_contains,omitempty"`
	NameNotContains           *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith            *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string                 `json:"name_not_ends_with,omitempty"`
	Concatenator              *string                 `json:"concatenator,omitempty"`
	ConcatenatorNot           *string                 `json:"concatenator_not,omitempty"`
	ConcatenatorIn            []string                `json:"concatenator_in,omitempty"`
	ConcatenatorNotIn         []string                `json:"concatenator_not_in,omitempty"`
	ConcatenatorLt            *string                 `json:"concatenator_lt,omitempty"`
	ConcatenatorLte           *string                 `json:"concatenator_lte,omitempty"`
	ConcatenatorGt            *string                 `json:"concatenator_gt,omitempty"`
	ConcatenatorGte           *string                 `json:"concatenator_gte,omitempty"`
	ConcatenatorContains      *string                 `json:"concatenator_contains,omitempty"`
	ConcatenatorNotContains   *string                 `json:"concatenator_not_contains,omitempty"`
	ConcatenatorStartsWith    *string                 `json:"concatenator_starts_with,omitempty"`
	ConcatenatorNotStartsWith *string                 `json:"concatenator_not_starts_with,omitempty"`
	ConcatenatorEndsWith      *string                 `json:"concatenator_ends_with,omitempty"`
	ConcatenatorNotEndsWith   *string                 `json:"concatenator_not_ends_with,omitempty"`
	Stage                     *string                 `json:"stage,omitempty"`
	StageNot                  *string                 `json:"stage_not,omitempty"`
	StageIn                   []string                `json:"stage_in,omitempty"`
	StageNotIn                []string                `json:"stage_not_in,omitempty"`
	StageLt                   *string                 `json:"stage_lt,omitempty"`
	StageLte                  *string                 `json:"stage_lte,omitempty"`
	StageGt                   *string                 `json:"stage_gt,omitempty"`
	StageGte                  *string                 `json:"stage_gte,omitempty"`
	StageContains             *string                 `json:"stage_contains,omitempty"`
	StageNotContains          *string                 `json:"stage_not_contains,omitempty"`
	StageStartsWith           *string                 `json:"stage_starts_with,omitempty"`
	StageNotStartsWith        *string                 `json:"stage_not_starts_with,omitempty"`
	StageEndsWith             *string                 `json:"stage_ends_with,omitempty"`
	StageNotEndsWith          *string                 `json:"stage_not_ends_with,omitempty"`
	Version                   *string                 `json:"version,omitempty"`
	VersionNot                *string                 `json:"version_not,omitempty"`
	VersionIn                 []string                `json:"version_in,omitempty"`
	VersionNotIn              []string                `json:"version_not_in,omitempty"`
	VersionLt                 *string                 `json:"version_lt,omitempty"`
	VersionLte                *string                 `json:"version_lte,omitempty"`
	VersionGt                 *string                 `json:"version_gt,omitempty"`
	VersionGte                *string                 `json:"version_gte,omitempty"`
	VersionContains           *string                 `json:"version_contains,omitempty"`
	VersionNotContains        *string                 `json:"version_not_contains,omitempty"`
	VersionStartsWith         *string                 `json:"version_starts_with,omitempty"`
	VersionNotStartsWith      *string                 `json:"version_not_starts_with,omitempty"`
	VersionEndsWith           *string                 `json:"version_ends_with,omitempty"`
	VersionNotEndsWith        *string                 `json:"version_not_ends_with,omitempty"`
	CreatedAt                 *string                 `json:"createdAt,omitempty"`
	CreatedAtNot              *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string                 `json:"updatedAt_gte,omitempty"`
	And                       []ModelScalarWhereInput `json:"AND,omitempty"`
	Or                        []ModelScalarWhereInput `json:"OR,omitempty"`
	Not                       []ModelScalarWhereInput `json:"NOT,omitempty"`
}

type ModelWhereInput struct {
	ID                        *int32               `json:"id,omitempty"`
	IDNot                     *int32               `json:"id_not,omitempty"`
	IDIn                      []int32              `json:"id_in,omitempty"`
	IDNotIn                   []int32              `json:"id_not_in,omitempty"`
	IDLt                      *int32               `json:"id_lt,omitempty"`
	IDLte                     *int32               `json:"id_lte,omitempty"`
	IDGt                      *int32               `json:"id_gt,omitempty"`
	IDGte                     *int32               `json:"id_gte,omitempty"`
	Name                      *string              `json:"name,omitempty"`
	NameNot                   *string              `json:"name_not,omitempty"`
	NameIn                    []string             `json:"name_in,omitempty"`
	NameNotIn                 []string             `json:"name_not_in,omitempty"`
	NameLt                    *string              `json:"name_lt,omitempty"`
	NameLte                   *string              `json:"name_lte,omitempty"`
	NameGt                    *string              `json:"name_gt,omitempty"`
	NameGte                   *string              `json:"name_gte,omitempty"`
	NameContains              *string              `json:"name_contains,omitempty"`
	NameNotContains           *string              `json:"name_not_contains,omitempty"`
	NameStartsWith            *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string              `json:"name_not_ends_with,omitempty"`
	Concatenator              *string              `json:"concatenator,omitempty"`
	ConcatenatorNot           *string              `json:"concatenator_not,omitempty"`
	ConcatenatorIn            []string             `json:"concatenator_in,omitempty"`
	ConcatenatorNotIn         []string             `json:"concatenator_not_in,omitempty"`
	ConcatenatorLt            *string              `json:"concatenator_lt,omitempty"`
	ConcatenatorLte           *string              `json:"concatenator_lte,omitempty"`
	ConcatenatorGt            *string              `json:"concatenator_gt,omitempty"`
	ConcatenatorGte           *string              `json:"concatenator_gte,omitempty"`
	ConcatenatorContains      *string              `json:"concatenator_contains,omitempty"`
	ConcatenatorNotContains   *string              `json:"concatenator_not_contains,omitempty"`
	ConcatenatorStartsWith    *string              `json:"concatenator_starts_with,omitempty"`
	ConcatenatorNotStartsWith *string              `json:"concatenator_not_starts_with,omitempty"`
	ConcatenatorEndsWith      *string              `json:"concatenator_ends_with,omitempty"`
	ConcatenatorNotEndsWith   *string              `json:"concatenator_not_ends_with,omitempty"`
	Stage                     *string              `json:"stage,omitempty"`
	StageNot                  *string              `json:"stage_not,omitempty"`
	StageIn                   []string             `json:"stage_in,omitempty"`
	StageNotIn                []string             `json:"stage_not_in,omitempty"`
	StageLt                   *string              `json:"stage_lt,omitempty"`
	StageLte                  *string              `json:"stage_lte,omitempty"`
	StageGt                   *string              `json:"stage_gt,omitempty"`
	StageGte                  *string              `json:"stage_gte,omitempty"`
	StageContains             *string              `json:"stage_contains,omitempty"`
	StageNotContains          *string              `json:"stage_not_contains,omitempty"`
	StageStartsWith           *string              `json:"stage_starts_with,omitempty"`
	StageNotStartsWith        *string              `json:"stage_not_starts_with,omitempty"`
	StageEndsWith             *string              `json:"stage_ends_with,omitempty"`
	StageNotEndsWith          *string              `json:"stage_not_ends_with,omitempty"`
	Version                   *string              `json:"version,omitempty"`
	VersionNot                *string              `json:"version_not,omitempty"`
	VersionIn                 []string             `json:"version_in,omitempty"`
	VersionNotIn              []string             `json:"version_not_in,omitempty"`
	VersionLt                 *string              `json:"version_lt,omitempty"`
	VersionLte                *string              `json:"version_lte,omitempty"`
	VersionGt                 *string              `json:"version_gt,omitempty"`
	VersionGte                *string              `json:"version_gte,omitempty"`
	VersionContains           *string              `json:"version_contains,omitempty"`
	VersionNotContains        *string              `json:"version_not_contains,omitempty"`
	VersionStartsWith         *string              `json:"version_starts_with,omitempty"`
	VersionNotStartsWith      *string              `json:"version_not_starts_with,omitempty"`
	VersionEndsWith           *string              `json:"version_ends_with,omitempty"`
	VersionNotEndsWith        *string              `json:"version_not_ends_with,omitempty"`
	ContainerIdEvery          *ContainerWhereInput `json:"containerId_every,omitempty"`
	ContainerIdSome           *ContainerWhereInput `json:"containerId_some,omitempty"`
	ContainerIdNone           *ContainerWhereInput `json:"containerId_none,omitempty"`
	CreatedAt                 *string              `json:"createdAt,omitempty"`
	CreatedAtNot              *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string              `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string              `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string              `json:"updatedAt_gte,omitempty"`
	And                       []ModelWhereInput    `json:"AND,omitempty"`
	Or                        []ModelWhereInput    `json:"OR,omitempty"`
	Not                       []ModelWhereInput    `json:"NOT,omitempty"`
}

type ModelCreateWithoutContainerIdInput struct {
	ID           *int32                       `json:"id,omitempty"`
	Name         string                       `json:"name"`
	SignalOrder  *ModelCreatesignalOrderInput `json:"signalOrder,omitempty"`
	Concatenator string                       `json:"concatenator"`
	Stage        string                       `json:"stage"`
	Version      string                       `json:"version"`
}

type ModelCreateInput struct {
	ID           *int32                                 `json:"id,omitempty"`
	Name         string                                 `json:"name"`
	SignalOrder  *ModelCreatesignalOrderInput           `json:"signalOrder,omitempty"`
	Concatenator string                                 `json:"concatenator"`
	Stage        string                                 `json:"stage"`
	Version      string                                 `json:"version"`
	ContainerId  *ContainerCreateManyWithoutModelsInput `json:"containerId,omitempty"`
}

type ModelCreatesignalOrderInput struct {
	Set []string `json:"set,omitempty"`
}

type ModelUpdateManyWithWhereNestedInput struct {
	Where ModelScalarWhereInput    `json:"where"`
	Data  ModelUpdateManyDataInput `json:"data"`
}

type ContainerUpdateInput struct {
	PublicationPoint *string                                 `json:"publicationPoint,omitempty"`
	Campaign         *string                                 `json:"campaign,omitempty"`
	Models           *ModelUpdateManyWithoutContainerIdInput `json:"models,omitempty"`
}

type ContainerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *ContainerWhereInput              `json:"node,omitempty"`
	And                        []ContainerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ContainerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ContainerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ModelUpdateManyWithoutContainerIdInput struct {
	Create     []ModelCreateWithoutContainerIdInput                `json:"create,omitempty"`
	Delete     []ModelWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []ModelWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []ModelWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []ModelWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []ModelUpdateWithWhereUniqueWithoutContainerIdInput `json:"update,omitempty"`
	Upsert     []ModelUpsertWithWhereUniqueWithoutContainerIdInput `json:"upsert,omitempty"`
	DeleteMany []ModelScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []ModelUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type ContainerUpdateManyDataInput struct {
	PublicationPoint *string `json:"publicationPoint,omitempty"`
	Campaign         *string `json:"campaign,omitempty"`
}

type ModelUpdateWithWhereUniqueWithoutContainerIdInput struct {
	Where ModelWhereUniqueInput                  `json:"where"`
	Data  ModelUpdateWithoutContainerIdDataInput `json:"data"`
}

type ContainerUpdateManyWithWhereNestedInput struct {
	Where ContainerScalarWhereInput    `json:"where"`
	Data  ContainerUpdateManyDataInput `json:"data"`
}

type ContainerUpdateWithWhereUniqueWithoutModelsInput struct {
	Where ContainerWhereUniqueInput             `json:"where"`
	Data  ContainerUpdateWithoutModelsDataInput `json:"data"`
}

type ContainerUpsertWithWhereUniqueWithoutModelsInput struct {
	Where  ContainerWhereUniqueInput             `json:"where"`
	Update ContainerUpdateWithoutModelsDataInput `json:"update"`
	Create ContainerCreateWithoutModelsInput     `json:"create"`
}

type ModelUpdatesignalOrderInput struct {
	Set []string `json:"set,omitempty"`
}

type ModelCreateManyWithoutContainerIdInput struct {
	Create  []ModelCreateWithoutContainerIdInput `json:"create,omitempty"`
	Connect []ModelWhereUniqueInput              `json:"connect,omitempty"`
}

type ContainerUpdateManyWithoutModelsInput struct {
	Create     []ContainerCreateWithoutModelsInput                `json:"create,omitempty"`
	Delete     []ContainerWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []ContainerWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []ContainerWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []ContainerWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []ContainerUpdateWithWhereUniqueWithoutModelsInput `json:"update,omitempty"`
	Upsert     []ContainerUpsertWithWhereUniqueWithoutModelsInput `json:"upsert,omitempty"`
	DeleteMany []ContainerScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []ContainerUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type ModelUpdateManyMutationInput struct {
	Name         *string                      `json:"name,omitempty"`
	SignalOrder  *ModelUpdatesignalOrderInput `json:"signalOrder,omitempty"`
	Concatenator *string                      `json:"concatenator,omitempty"`
	Stage        *string                      `json:"stage,omitempty"`
	Version      *string                      `json:"version,omitempty"`
}

type ModelUpdateInput struct {
	Name         *string                                `json:"name,omitempty"`
	SignalOrder  *ModelUpdatesignalOrderInput           `json:"signalOrder,omitempty"`
	Concatenator *string                                `json:"concatenator,omitempty"`
	Stage        *string                                `json:"stage,omitempty"`
	Version      *string                                `json:"version,omitempty"`
	ContainerId  *ContainerUpdateManyWithoutModelsInput `json:"containerId,omitempty"`
}

type ContainerScalarWhereInput struct {
	ID                            *int32                      `json:"id,omitempty"`
	IDNot                         *int32                      `json:"id_not,omitempty"`
	IDIn                          []int32                     `json:"id_in,omitempty"`
	IDNotIn                       []int32                     `json:"id_not_in,omitempty"`
	IDLt                          *int32                      `json:"id_lt,omitempty"`
	IDLte                         *int32                      `json:"id_lte,omitempty"`
	IDGt                          *int32                      `json:"id_gt,omitempty"`
	IDGte                         *int32                      `json:"id_gte,omitempty"`
	PublicationPoint              *string                     `json:"publicationPoint,omitempty"`
	PublicationPointNot           *string                     `json:"publicationPoint_not,omitempty"`
	PublicationPointIn            []string                    `json:"publicationPoint_in,omitempty"`
	PublicationPointNotIn         []string                    `json:"publicationPoint_not_in,omitempty"`
	PublicationPointLt            *string                     `json:"publicationPoint_lt,omitempty"`
	PublicationPointLte           *string                     `json:"publicationPoint_lte,omitempty"`
	PublicationPointGt            *string                     `json:"publicationPoint_gt,omitempty"`
	PublicationPointGte           *string                     `json:"publicationPoint_gte,omitempty"`
	PublicationPointContains      *string                     `json:"publicationPoint_contains,omitempty"`
	PublicationPointNotContains   *string                     `json:"publicationPoint_not_contains,omitempty"`
	PublicationPointStartsWith    *string                     `json:"publicationPoint_starts_with,omitempty"`
	PublicationPointNotStartsWith *string                     `json:"publicationPoint_not_starts_with,omitempty"`
	PublicationPointEndsWith      *string                     `json:"publicationPoint_ends_with,omitempty"`
	PublicationPointNotEndsWith   *string                     `json:"publicationPoint_not_ends_with,omitempty"`
	Campaign                      *string                     `json:"campaign,omitempty"`
	CampaignNot                   *string                     `json:"campaign_not,omitempty"`
	CampaignIn                    []string                    `json:"campaign_in,omitempty"`
	CampaignNotIn                 []string                    `json:"campaign_not_in,omitempty"`
	CampaignLt                    *string                     `json:"campaign_lt,omitempty"`
	CampaignLte                   *string                     `json:"campaign_lte,omitempty"`
	CampaignGt                    *string                     `json:"campaign_gt,omitempty"`
	CampaignGte                   *string                     `json:"campaign_gte,omitempty"`
	CampaignContains              *string                     `json:"campaign_contains,omitempty"`
	CampaignNotContains           *string                     `json:"campaign_not_contains,omitempty"`
	CampaignStartsWith            *string                     `json:"campaign_starts_with,omitempty"`
	CampaignNotStartsWith         *string                     `json:"campaign_not_starts_with,omitempty"`
	CampaignEndsWith              *string                     `json:"campaign_ends_with,omitempty"`
	CampaignNotEndsWith           *string                     `json:"campaign_not_ends_with,omitempty"`
	CreatedAt                     *string                     `json:"createdAt,omitempty"`
	CreatedAtNot                  *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string                     `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string                     `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string                     `json:"updatedAt_gte,omitempty"`
	And                           []ContainerScalarWhereInput `json:"AND,omitempty"`
	Or                            []ContainerScalarWhereInput `json:"OR,omitempty"`
	Not                           []ContainerScalarWhereInput `json:"NOT,omitempty"`
}

type ContainerCreateManyWithoutModelsInput struct {
	Create  []ContainerCreateWithoutModelsInput `json:"create,omitempty"`
	Connect []ContainerWhereUniqueInput         `json:"connect,omitempty"`
}

type ContainerUpdateManyMutationInput struct {
	PublicationPoint *string `json:"publicationPoint,omitempty"`
	Campaign         *string `json:"campaign,omitempty"`
}

type ModelUpdateManyDataInput struct {
	Name         *string                      `json:"name,omitempty"`
	SignalOrder  *ModelUpdatesignalOrderInput `json:"signalOrder,omitempty"`
	Concatenator *string                      `json:"concatenator,omitempty"`
	Stage        *string                      `json:"stage,omitempty"`
	Version      *string                      `json:"version,omitempty"`
}

type ContainerCreateWithoutModelsInput struct {
	ID               *int32 `json:"id,omitempty"`
	PublicationPoint string `json:"publicationPoint"`
	Campaign         string `json:"campaign"`
}

type ContainerUpdateWithoutModelsDataInput struct {
	PublicationPoint *string `json:"publicationPoint,omitempty"`
	Campaign         *string `json:"campaign,omitempty"`
}

type ModelWhereUniqueInput struct {
	ID   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type ModelSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ModelWhereInput              `json:"node,omitempty"`
	And                        []ModelSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ModelSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ModelSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ContainerCreateInput struct {
	ID               *int32                                  `json:"id,omitempty"`
	PublicationPoint string                                  `json:"publicationPoint"`
	Campaign         string                                  `json:"campaign"`
	Models           *ModelCreateManyWithoutContainerIdInput `json:"models,omitempty"`
}

type ModelPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ModelPreviousValuesExec) Exec(ctx context.Context) (*ModelPreviousValues, error) {
	var v ModelPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ModelPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ModelPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ModelPreviousValuesExecArray) Exec(ctx context.Context) ([]ModelPreviousValues, error) {
	var v []ModelPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ModelPreviousValues struct {
	ID           int32    `json:"id"`
	Name         string   `json:"name"`
	SignalOrder  []string `json:"signalOrder,omitempty"`
	Concatenator string   `json:"concatenator"`
	Stage        string   `json:"stage"`
	Version      string   `json:"version"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type ModelConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ModelConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ModelConnectionExec) Edges() *ModelEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ModelEdge"},
		"edges",
		[]string{"cursor"})

	return &ModelEdgeExec{ret}
}

func (instance *ModelConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateModel"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ModelConnectionExec) Exec(ctx context.Context) (*ModelConnection, error) {
	var v ModelConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ModelConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ModelConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ModelConnectionExecArray) Exec(ctx context.Context) ([]ModelConnection, error) {
	var v []ModelConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ModelConnection struct {
}

type ContainerExec struct {
	exec *prisma.Exec
}

type ModelsParamsExec struct {
	Where   *ModelWhereInput
	OrderBy *ModelOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ContainerExec) Models(params *ModelsParamsExec) *ModelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ModelWhereInput", "ModelOrderByInput", "Model"},
		"models",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExecArray{ret}
}

func (instance ContainerExec) Exec(ctx context.Context) (*Container, error) {
	var v Container
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContainerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContainerExecArray struct {
	exec *prisma.Exec
}

func (instance ContainerExecArray) Exec(ctx context.Context) ([]Container, error) {
	var v []Container
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Container struct {
	ID               int32  `json:"id"`
	PublicationPoint string `json:"publicationPoint"`
	Campaign         string `json:"campaign"`
	CreatedAt        string `json:"createdAt"`
	UpdatedAt        string `json:"updatedAt"`
}

type ContainerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ContainerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ContainerConnectionExec) Edges() *ContainerEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ContainerEdge"},
		"edges",
		[]string{"cursor"})

	return &ContainerEdgeExec{ret}
}

func (instance *ContainerConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateContainer"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ContainerConnectionExec) Exec(ctx context.Context) (*ContainerConnection, error) {
	var v ContainerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContainerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContainerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ContainerConnectionExecArray) Exec(ctx context.Context) ([]ContainerConnection, error) {
	var v []ContainerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ContainerConnection struct {
}

type ContainerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ContainerSubscriptionPayloadExec) Node() *ContainerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Container"},
		"node",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

func (instance *ContainerSubscriptionPayloadExec) PreviousValues() *ContainerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ContainerPreviousValues"},
		"previousValues",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerPreviousValuesExec{ret}
}

func (instance ContainerSubscriptionPayloadExec) Exec(ctx context.Context) (*ContainerSubscriptionPayload, error) {
	var v ContainerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContainerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContainerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ContainerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ContainerSubscriptionPayload, error) {
	var v []ContainerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ContainerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ContainerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ContainerPreviousValuesExec) Exec(ctx context.Context) (*ContainerPreviousValues, error) {
	var v ContainerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContainerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContainerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ContainerPreviousValuesExecArray) Exec(ctx context.Context) ([]ContainerPreviousValues, error) {
	var v []ContainerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ContainerPreviousValues struct {
	ID               int32  `json:"id"`
	PublicationPoint string `json:"publicationPoint"`
	Campaign         string `json:"campaign"`
	CreatedAt        string `json:"createdAt"`
	UpdatedAt        string `json:"updatedAt"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type ModelExec struct {
	exec *prisma.Exec
}

type ContainerIdParamsExec struct {
	Where   *ContainerWhereInput
	OrderBy *ContainerOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ModelExec) ContainerId(params *ContainerIdParamsExec) *ContainerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ContainerWhereInput", "ContainerOrderByInput", "Container"},
		"containerId",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExecArray{ret}
}

func (instance ModelExec) Exec(ctx context.Context) (*Model, error) {
	var v Model
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ModelExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ModelExecArray struct {
	exec *prisma.Exec
}

func (instance ModelExecArray) Exec(ctx context.Context) ([]Model, error) {
	var v []Model
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Model struct {
	ID           int32    `json:"id"`
	Name         string   `json:"name"`
	SignalOrder  []string `json:"signalOrder,omitempty"`
	Concatenator string   `json:"concatenator"`
	Stage        string   `json:"stage"`
	Version      string   `json:"version"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type ModelEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ModelEdgeExec) Node() *ModelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Model"},
		"node",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

func (instance ModelEdgeExec) Exec(ctx context.Context) (*ModelEdge, error) {
	var v ModelEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ModelEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ModelEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ModelEdgeExecArray) Exec(ctx context.Context) ([]ModelEdge, error) {
	var v []ModelEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ModelEdge struct {
	Cursor string `json:"cursor"`
}

type ModelSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ModelSubscriptionPayloadExec) Node() *ModelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Model"},
		"node",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelExec{ret}
}

func (instance *ModelSubscriptionPayloadExec) PreviousValues() *ModelPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ModelPreviousValues"},
		"previousValues",
		[]string{"id", "name", "signalOrder", "concatenator", "stage", "version", "createdAt", "updatedAt"})

	return &ModelPreviousValuesExec{ret}
}

func (instance ModelSubscriptionPayloadExec) Exec(ctx context.Context) (*ModelSubscriptionPayload, error) {
	var v ModelSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ModelSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ModelSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ModelSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ModelSubscriptionPayload, error) {
	var v []ModelSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ModelSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ContainerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ContainerEdgeExec) Node() *ContainerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Container"},
		"node",
		[]string{"id", "publicationPoint", "campaign", "createdAt", "updatedAt"})

	return &ContainerExec{ret}
}

func (instance ContainerEdgeExec) Exec(ctx context.Context) (*ContainerEdge, error) {
	var v ContainerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContainerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContainerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ContainerEdgeExecArray) Exec(ctx context.Context) ([]ContainerEdge, error) {
	var v []ContainerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ContainerEdge struct {
	Cursor string `json:"cursor"`
}
